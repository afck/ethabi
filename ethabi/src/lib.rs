//! Ethereum ABI encoding decoding library.

#![warn(missing_docs)]

extern crate rustc_hex as hex;
extern crate serde;
extern crate serde_json;
extern crate tiny_keccak;

#[macro_use]
extern crate serde_derive;

#[macro_use]
extern crate error_chain;

#[doc(hidden)]
pub extern crate futures;
extern crate ethereum_types;

pub mod param_type;
pub mod token;
mod constructor;
mod contract;
mod decoder;
mod encoder;
mod errors;
mod event;
mod event_param;
mod filter;
mod function;
mod log;
mod operation;
mod param;
mod signature;
mod util;

pub use param_type::ParamType;
pub use constructor::Constructor;
pub use contract::{Contract, Functions, Events};
pub use token::Token;
pub use errors::{Error, ErrorKind, Result, ResultExt};
pub use encoder::encode;
pub use decoder::decode;
pub use filter::{Topic, TopicFilter, RawTopicFilter};
pub use function::Function;
pub use param::Param;
pub use log::{Log, RawLog, LogParam, ParseLog};
pub use event::Event;
pub use event_param::EventParam;
use futures::Future;

/// ABI address.
pub type Address = ethereum_types::Address;

/// ABI fixed bytes.
pub type FixedBytes = Vec<u8>;

/// ABI bytes.
pub type Bytes = Vec<u8>;

/// ABI signed integer.
pub type Int = ethereum_types::U256;

/// ABI unsigned integer.
pub type Uint = ethereum_types::U256;

/// Commonly used FixedBytes of size 32
pub type Hash = ethereum_types::H256;

/// Contract functions generated by ethabi-derive
pub trait ContractFunction {
	/// Output types of the contract function
	type Output;

	/// Encodes the input for the contract function
	fn encoded(&self) -> Bytes;

	/// Decodes the given bytes output for the contract function
	fn output(&self, Bytes) -> Result<Self::Output>;
}

/// Trait that adds `.call(caller)` and `.transact(caller)` to contract functions.
/// These functions get delegated to the caller.
pub trait DelegateCall<O> {
	/// Delegates call to caller
	fn call<C: Call<O>>(self, caller: C) -> C::Result;

	/// Delegates transaction to caller
	fn transact<T: Transact<O>>(self, caller: T) -> T::Result;
}
impl<O, E: ContractFunction<Output=O> + 'static> DelegateCall<O> for E {
	fn call<C: Call<O>>(self, caller: C) -> C::Result {
		caller.call(self.encoded(), move |bytes| self.output(bytes))
	}

	fn transact<T: Transact<O>>(self, caller: T) -> T::Result {
		caller.transact(self.encoded(), move |bytes| self.output(bytes))
	}
}

/// A caller (for example a closure) that can process a call and
/// return the decoded output.
pub trait Call<Out>: Sized {
	/// Return type of the call
	type Result;

	/// Processes the call given input bytes and returns decoded output
	fn call<D: 'static>(self, input: Bytes, output_decoder: D) -> Self::Result
		where D: FnOnce(Bytes) -> Result<Out>;
}
// Blanket implementation for closures
impl<Out: 'static, F, R: 'static> Call<Out> for F where
	R: futures::IntoFuture<Item=Bytes, Error=String>,
	F: FnOnce(Bytes) -> R
{
	type Result = Box<futures::Future<Item=Out, Error=Error>>;

	fn call<D: 'static>(self, input: Bytes, output_decoder: D) -> Self::Result
		where D: FnOnce(Bytes) -> Result<Out>
	{
		Box::new(
			(self)(input).into_future().map_err(|e: String| Error::with_chain(Error::from(e), ErrorKind::CallError)).and_then(output_decoder)
		)
	}

}

/// A caller (for example a closure) that can process a transaction and
/// return the decoded output.
pub trait Transact<Out>: Sized {
	/// Return type of the transaction
	type Result;

	/// Processes the transaction given input bytes and returns decoded output
	fn transact<D: 'static>(self, input: Bytes, output_decoder: D) -> Self::Result
		where D: FnOnce(Bytes) -> Result<Out>;
}
// Blanket implementation for closures.
impl<Out: 'static, F, R: 'static> Transact<Out> for F where
	R: futures::IntoFuture<Item=Bytes, Error=String>,
	F: FnOnce(Bytes) -> R
{
	type Result = Box<futures::Future<Item=Out, Error=Error>>;

	fn transact<D: 'static>(self, input: Bytes, output_decoder: D) -> Self::Result
		where D: FnOnce(Bytes) -> Result<Out>
	{
		Box::new(
			(self)(input).into_future().map_err(|e: String| Error::with_chain(Error::from(e), ErrorKind::TransactError)).and_then(output_decoder)
		)
	}
}
